## 只读属性
一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性
TypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：
```
interface Point {
    readonly x: number;
    readonly y: number;
}

let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
```

## 接口与类
 * 一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，
 * 这时候就可以把特性提取成接口（interfaces），
 * 用 implements 关键字来实现。
 * 这个特性大大提高了面向对象的灵活性。
 * 一个类可以实现多个接口
 * 接口可以继承接口
 * 接口也可以继承继承类

## 泛型约束

```
interface Lengthwise {
    length: number;
}
function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length);  // Now we know it has a .length property, so no more error
    return arg;
}
```

## 多重泛型
```
class Pair<K,V>{
key:k;
value:V;
}
```

## keyof
keyof 与 Object.keys 略有相似，只不过 keyof 取 interface 的键。
```
interface Point {
    x: number;
    y: number;
}

// type keys = "x" | "y"
type keys = keyof Point;

```

## Partial & Pick
```
type Partial<T> = {
  [P in keyof T]?: T[P];
};

type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

interface User {
  id: number;
  age: number;
  name: string;
};

// 相当于: type PartialUser = { id?: number; age?: number; name?: string; }
type PartialUser = Partial<User>

// 相当于: type PickUser = { id: number; age: number; }
type PickUser = Pick<User, "id" | "age">
```

## Condition Type
类似于 js 中的 ?: 运算符，可以使用它扩展一些基本类型
```
T extends U ? X : Y

type isTrue<T> = T extends true ? true : false
// 相当于 type t = false
type t = isTrue<number>

// 相当于 type t = false
type t1 = isTrue<false>
```

## Never
never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。
```
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
}

```

## never & Exclude & Omit
结合 never 与 conditional type 可以推出很多有意思而且实用的类型，比如 Omit
```
type Exclude<T, U> = T extends U ? never : T;

// 相当于: type A = 'a'
type A = Exclude<'x' | 'a', 'x' | 'y' | 'z'>
```
结合 Exclude 可以推出 Omit 的写法
```
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;

interface User {
  id: number;
  age: number;
  name: string;
};

// 相当于: type PickUser = { age: number; name: string; }
type OmitUser = Omit<User, "id">
```

## typeof
官方："类型别名 可以和interface关键字一样，然而他们有一些细微的差别。"
顾名思义，typeof 代表取某个值的 type，可以从以下示例来展示他们的用法
```
const a: number = 3

// 相当于: const b: number = 4
const b: typeof a = 4
```

## type 和 interface 

### 相同点

都可以描述一个对象或者函数
都允许拓展（extends）

#### type extends type

```

type Name = { 
  name: string; 
}
type User = Name & { age: number  };
```

#### interface extends type

```

type Name = { 
  name: string; 
}
interface User extends Name { 
  age: number; 
}
```

#### type extends interface

```

interface Name { 
  name: string; 
}
type User = Name & { 
  age: number; 
}
```

### type 可以而 interface 不行

type 可以声明基本类型别名，联合类型，元组等类型
type 语句中还可以使用 typeof 获取实例的 类型进行赋值

```

// 基本类型别名
type Name = string
 
// 联合类型
interface Dog {
    wong();
}
interface Cat {
    miao();
}
 
type Pet = Dog | Cat
 
// 具体定义数组每个位置的类型
type PetList = [Dog, Pet]
```

```

// 当你想获取一个变量的类型时，使用 typeof
let div = document.createElement('div');
type B = typeof div
```

### interface 可以而 type 不行

interface 能够声明合并
```
interface User {
  name: string
  age: number
}

interface User {
  sex: string
}

/*
User 接口为 {
  name: string
  age: number
  sex: string 
}
*/

```

### type 特性

声明一个非空的类型

```
type NonNullable<T> = T extends null | undefined ? never : T;
```

创建一颗tree

```
type Tree<T> = T & { parent: Tree<T> };
```